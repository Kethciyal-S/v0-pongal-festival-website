<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pongalo Pongal</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      font-family: 'Georgia', serif;
    }

    canvas {
      display: block;
    }

    .title {
      position: absolute;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 3.5rem;
      font-weight: bold;
      color: #8B0000;
      text-shadow: 
        3px 3px 0 #FFD700,
        -1px -1px 0 #FFD700,
        1px -1px 0 #FFD700,
        -1px 1px 0 #FFD700;
      letter-spacing: 4px;
      animation: titlePulse 2s ease-in-out infinite;
      z-index: 10;
    }

    @keyframes titlePulse {
      0%, 100% { transform: translateX(-50%) scale(1); }
      50% { transform: translateX(-50%) scale(1.05); }
    }

    .subtitle {
      position: absolute;
      top: 110px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.2rem;
      color: #B8860B;
      letter-spacing: 8px;
      z-index: 10;
    }
  </style>
</head>
<body>
  <h1 class="title">Pongalo Pongal</h1>
  <p class="subtitle">HARVEST FESTIVAL</p>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let width, height;
    let time = 0;
    let steamParticles = [];
    let bubbles = [];
    let overflowDrops = [];

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }

    resize();
    window.addEventListener('resize', resize);

    // Steam particle class
    class SteamParticle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = Math.random() * 20 + 10;
        this.speedY = Math.random() * 1.5 + 0.5;
        this.speedX = (Math.random() - 0.5) * 0.5;
        this.opacity = Math.random() * 0.3 + 0.1;
        this.life = 1;
      }

      update() {
        this.y -= this.speedY;
        this.x += this.speedX + Math.sin(time * 0.05 + this.y * 0.01) * 0.5;
        this.life -= 0.008;
        this.size += 0.3;
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity * this.life})`;
        ctx.fill();
      }
    }

    // Bubble class for boiling effect
    class Bubble {
      constructor(potX, potY, potWidth) {
        this.potX = potX;
        this.potWidth = potWidth;
        this.reset();
        this.y = potY - Math.random() * 30;
      }

      reset() {
        this.x = this.potX + (Math.random() - 0.5) * this.potWidth * 0.6;
        this.y = height * 0.55;
        this.size = Math.random() * 8 + 3;
        this.speed = Math.random() * 2 + 1;
      }

      update() {
        this.y -= this.speed;
        this.x += Math.sin(time * 0.1 + this.x) * 0.5;
        if (this.y < height * 0.4) {
          this.reset();
        }
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 250, 220, 0.6)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.stroke();
      }
    }

    // Overflow drop class
    class OverflowDrop {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.speedX = (Math.random() - 0.5) * 2;
        this.speedY = Math.random() * 2 + 1;
        this.size = Math.random() * 8 + 5;
        this.life = 1;
      }

      update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.speedY += 0.1;
        this.life -= 0.015;
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 248, 220, ${this.life})`;
        ctx.fill();
      }
    }

    // Draw sun with rays
    function drawSun() {
      const sunX = width * 0.85;
      const sunY = height * 0.15;
      const sunRadius = 60;

      // Sun glow
      const gradient = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunRadius * 3);
      gradient.addColorStop(0, 'rgba(255, 200, 50, 0.8)');
      gradient.addColorStop(0.5, 'rgba(255, 150, 50, 0.3)');
      gradient.addColorStop(1, 'rgba(255, 100, 50, 0)');
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunRadius * 3, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();

      // Sun rays
      ctx.save();
      ctx.translate(sunX, sunY);
      ctx.rotate(time * 0.01);
      for (let i = 0; i < 12; i++) {
        ctx.rotate(Math.PI / 6);
        ctx.beginPath();
        ctx.moveTo(sunRadius + 10, 0);
        ctx.lineTo(sunRadius + 40 + Math.sin(time * 0.05 + i) * 10, -8);
        ctx.lineTo(sunRadius + 40 + Math.sin(time * 0.05 + i) * 10, 8);
        ctx.closePath();
        ctx.fillStyle = '#FFD700';
        ctx.fill();
      }
      ctx.restore();

      // Sun body
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
      const sunGrad = ctx.createRadialGradient(sunX - 20, sunY - 20, 0, sunX, sunY, sunRadius);
      sunGrad.addColorStop(0, '#FFFF00');
      sunGrad.addColorStop(1, '#FFA500');
      ctx.fillStyle = sunGrad;
      ctx.fill();

      // Sun face
      ctx.fillStyle = '#FF8C00';
      ctx.beginPath();
      ctx.arc(sunX - 15, sunY - 10, 6, 0, Math.PI * 2);
      ctx.arc(sunX + 15, sunY - 10, 6, 0, Math.PI * 2);
      ctx.fill();

      ctx.beginPath();
      ctx.arc(sunX, sunY + 10, 20, 0.1 * Math.PI, 0.9 * Math.PI);
      ctx.strokeStyle = '#FF8C00';
      ctx.lineWidth = 4;
      ctx.stroke();
    }

    // Draw kolam pattern
    function drawKolam(x, y, size) {
      ctx.save();
      ctx.translate(x, y);

      // Main pattern
      for (let i = 0; i < 8; i++) {
        ctx.rotate(Math.PI / 4);

        // Outer petals
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(size * 0.5, -size * 0.3, size, 0);
        ctx.quadraticCurveTo(size * 0.5, size * 0.3, 0, 0);
        ctx.strokeStyle = '#FFFFFF';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Inner details
        ctx.beginPath();
        ctx.arc(size * 0.5, 0, size * 0.15, 0, Math.PI * 2);
        ctx.stroke();
      }

      // Center dot
      ctx.beginPath();
      ctx.arc(0, 0, size * 0.1, 0, Math.PI * 2);
      ctx.fillStyle = '#FF6B6B';
      ctx.fill();

      // Surrounding dots
      for (let i = 0; i < 8; i++) {
        ctx.rotate(Math.PI / 4);
        ctx.beginPath();
        ctx.arc(size * 0.3, 0, size * 0.05, 0, Math.PI * 2);
        ctx.fillStyle = '#FFD700';
        ctx.fill();
      }

      ctx.restore();
    }

    // Draw Pongal pot
    function drawPot(x, y, potWidth, potHeight) {
      // Pot body gradient
      const potGrad = ctx.createLinearGradient(x - potWidth / 2, y, x + potWidth / 2, y);
      potGrad.addColorStop(0, '#8B4513');
      potGrad.addColorStop(0.3, '#CD853F');
      potGrad.addColorStop(0.5, '#DEB887');
      potGrad.addColorStop(0.7, '#CD853F');
      potGrad.addColorStop(1, '#8B4513');

      // Pot body
      ctx.beginPath();
      ctx.moveTo(x - potWidth / 2, y);
      ctx.quadraticCurveTo(x - potWidth / 2 - 20, y + potHeight * 0.5, x - potWidth * 0.3, y + potHeight);
      ctx.lineTo(x + potWidth * 0.3, y + potHeight);
      ctx.quadraticCurveTo(x + potWidth / 2 + 20, y + potHeight * 0.5, x + potWidth / 2, y);
      ctx.closePath();
      ctx.fillStyle = potGrad;
      ctx.fill();
      ctx.strokeStyle = '#5D3A1A';
      ctx.lineWidth = 3;
      ctx.stroke();

      // Pot rim
      ctx.beginPath();
      ctx.ellipse(x, y, potWidth / 2 + 10, 15, 0, 0, Math.PI * 2);
      ctx.fillStyle = '#A0522D';
      ctx.fill();
      ctx.strokeStyle = '#5D3A1A';
      ctx.stroke();

      // Pongal inside pot (boiling)
      const boilOffset = Math.sin(time * 0.15) * 5;
      ctx.beginPath();
      ctx.ellipse(x, y + 5 + boilOffset, potWidth / 2 - 5, 12, 0, 0, Math.PI * 2);
      const pongalGrad = ctx.createRadialGradient(x, y + 5, 0, x, y + 5, potWidth / 2);
      pongalGrad.addColorStop(0, '#FFFACD');
      pongalGrad.addColorStop(1, '#F4A460');
      ctx.fillStyle = pongalGrad;
      ctx.fill();

      // Overflow effect
      if (Math.random() < 0.1) {
        const overflowX = x + (Math.random() - 0.5) * potWidth * 0.8;
        overflowDrops.push(new OverflowDrop(overflowX, y - 5));
      }

      // Draw overflow drops
      overflowDrops = overflowDrops.filter(drop => drop.life > 0);
      overflowDrops.forEach(drop => {
        drop.update();
        drop.draw();
      });

      // Decorative patterns on pot
      ctx.strokeStyle = '#FFD700';
      ctx.lineWidth = 2;
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.arc(x, y + potHeight * 0.3 + i * 25, potWidth * 0.35 - i * 10, 0.2 * Math.PI, 0.8 * Math.PI);
        ctx.stroke();
      }

      // Turmeric plant decoration
      drawTurmericPlant(x - 5, y - 20);

      return { x, y };
    }

    // Draw turmeric plant on pot
    function drawTurmericPlant(x, y) {
      ctx.strokeStyle = '#228B22';
      ctx.lineWidth = 3;
      ctx.fillStyle = '#32CD32';

      // Stem
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.quadraticCurveTo(x + 5, y - 30, x - 5, y - 50);
      ctx.stroke();

      // Leaves
      for (let i = 0; i < 3; i++) {
        ctx.save();
        ctx.translate(x, y - 15 - i * 15);
        ctx.rotate(Math.sin(time * 0.03 + i) * 0.1);

        ctx.beginPath();
        ctx.ellipse(15, 0, 20, 8, 0.3, 0, Math.PI * 2);
        ctx.fillStyle = '#228B22';
        ctx.fill();

        ctx.beginPath();
        ctx.ellipse(-15, 0, 20, 8, -0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      // Turmeric tied with thread
      ctx.fillStyle = '#FFD700';
      ctx.beginPath();
      ctx.arc(x, y - 5, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#FF0000';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // Draw fire under pot
    function drawFire(x, y) {
      const flames = [
        { offset: -30, height: 40, width: 20 },
        { offset: 0, height: 55, width: 25 },
        { offset: 30, height: 40, width: 20 },
        { offset: -15, height: 45, width: 18 },
        { offset: 15, height: 45, width: 18 }
      ];

      flames.forEach((flame, i) => {
        const flicker = Math.sin(time * 0.2 + i * 2) * 5;
        const flameHeight = flame.height + flicker;

        const gradient = ctx.createLinearGradient(x + flame.offset, y, x + flame.offset, y - flameHeight);
        gradient.addColorStop(0, '#FF4500');
        gradient.addColorStop(0.3, '#FF6600');
        gradient.addColorStop(0.6, '#FFD700');
        gradient.addColorStop(1, 'rgba(255, 255, 0, 0)');

        ctx.beginPath();
        ctx.moveTo(x + flame.offset - flame.width / 2, y);
        ctx.quadraticCurveTo(
          x + flame.offset - flame.width / 2 + Math.sin(time * 0.3 + i) * 5,
          y - flameHeight / 2,
          x + flame.offset,
          y - flameHeight
        );
        ctx.quadraticCurveTo(
          x + flame.offset + flame.width / 2 + Math.sin(time * 0.3 + i + 1) * 5,
          y - flameHeight / 2,
          x + flame.offset + flame.width / 2,
          y
        );
        ctx.closePath();
        ctx.fillStyle = gradient;
        ctx.fill();
      });

      // Wood logs
      ctx.fillStyle = '#4A2F1A';
      ctx.beginPath();
      ctx.ellipse(x - 25, y + 10, 40, 8, -0.2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(x + 25, y + 10, 40, 8, 0.2, 0, Math.PI * 2);
      ctx.fill();

      // Bricks
      ctx.fillStyle = '#8B0000';
      ctx.fillRect(x - 70, y + 15, 30, 20);
      ctx.fillRect(x + 40, y + 15, 30, 20);
      ctx.fillRect(x - 55, y + 35, 30, 15);
      ctx.fillRect(x + 25, y + 35, 30, 15);
    }

    // Draw sugarcane
    function drawSugarcane(x, y, height) {
      ctx.strokeStyle = '#9ACD32';
      ctx.lineWidth = 15;

      // Cane body
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.sin(time * 0.02) * 10, y - height);
      ctx.stroke();

      // Segments
      ctx.strokeStyle = '#6B8E23';
      ctx.lineWidth = 2;
      for (let i = 0; i < height; i += 30) {
        ctx.beginPath();
        ctx.moveTo(x - 8, y - i);
        ctx.lineTo(x + 8, y - i);
        ctx.stroke();
      }

      // Leaves at top
      ctx.fillStyle = '#228B22';
      for (let i = 0; i < 5; i++) {
        ctx.save();
        ctx.translate(x + Math.sin(time * 0.02) * 10, y - height);
        ctx.rotate(-0.5 + i * 0.25 + Math.sin(time * 0.03 + i) * 0.1);
        ctx.beginPath();
        ctx.ellipse(0, -40, 8, 50, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    // Main draw function
    function draw() {
      // Sky gradient background
      const skyGrad = ctx.createLinearGradient(0, 0, 0, height);
      skyGrad.addColorStop(0, '#87CEEB');
      skyGrad.addColorStop(0.5, '#FFE4B5');
      skyGrad.addColorStop(1, '#F4A460');
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, width, height);

      // Sun
      drawSun();

      // Ground
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(0, height * 0.75, width, height * 0.25);

      // Kolam patterns on ground
      drawKolam(width * 0.2, height * 0.85, 40);
      drawKolam(width * 0.8, height * 0.85, 40);
      drawKolam(width * 0.5, height * 0.92, 50);
      drawKolam(width * 0.35, height * 0.88, 30);
      drawKolam(width * 0.65, height * 0.88, 30);

      // Sugarcanes
      drawSugarcane(width * 0.15, height * 0.75, 250);
      drawSugarcane(width * 0.85, height * 0.75, 280);

      const potX = width / 2;
      const potY = height * 0.45;
      const potWidth = 150;
      const potHeight = 120;

      // Fire
      drawFire(potX, potY + potHeight + 20);

      // Pot
      const potPos = drawPot(potX, potY, potWidth, potHeight);

      // Initialize bubbles
      if (bubbles.length === 0) {
        for (let i = 0; i < 15; i++) {
          bubbles.push(new Bubble(potX, potY, potWidth));
        }
      }

      // Update and draw bubbles
      bubbles.forEach(bubble => {
        bubble.update();
        bubble.draw();
      });

      // Add steam particles
      if (Math.random() < 0.3) {
        const steamX = potX + (Math.random() - 0.5) * potWidth * 0.5;
        steamParticles.push(new SteamParticle(steamX, potY - 20));
      }

      // Update and draw steam
      steamParticles = steamParticles.filter(p => p.life > 0);
      steamParticles.forEach(particle => {
        particle.update();
        particle.draw();
      });

      time++;
      requestAnimationFrame(draw);
    }

    draw();
  </script>
</body>
</html>
